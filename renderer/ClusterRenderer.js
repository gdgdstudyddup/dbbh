import { GPU } from "../gpu/GPU.js";

export class ClusterRenderer {
    constructor(gpu) {
        this.gpu = gpu || new GPU();
    }
    setEncoder(gpu) {
        this.commandEncoder = gpu.commandEncoder;
    }
    setCurrentPass(pass) {
        this.currentPass = pass;
    }
    prepareRenderToScreen(view) {
        this.currentPass.colorAttachments[0].view = view;
    }
    beginCurrentPass() {
        this.currentPassEncoder = this.commandEncoder.beginRenderPass(this.currentPass);
    }
    beginPass(pass) { // pass == renderPassDescriptor
        this.currentPassEncoder = this.commandEncoder.beginRenderPass(pass);
    }
    endPass(pass) {
        pass.end();
    }
    endCurrentPass() {
        this.currentPassEncoder.end();
    }
    setPipeline(pipeline) {
        this.currentPassEncoder.setPipeline(pipeline);
    }

    setBindGroup(groupIndex, group) {
        this.currentPassEncoder.setBindGroup(groupIndex, group);
    }

    setVertexBuffer(slot, buffer, offset = 0) {
        this.currentPassEncoder.setVertexBuffer(slot, buffer, offset);
    }

    setIndexBuffer(buffer, indexFormat, offset = 0) {
        this.currentPassEncoder.setIndexBuffer(buffer, indexFormat, offset);
    }


    drawArray(indexCount, instanceCount, firstIndex, baseVertex, firstInstance) {
        this.currentPassEncoder.draw(indexCount, instanceCount, firstIndex, baseVertex, firstInstance)
    }

    drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance) {
        this.currentPassEncoder.drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance);
    }

    drawIndexedIndirect(buffer, offset = 0) {
        this.currentPassEncoder.drawIndexedIndirect(buffer, offset);
    }

    render() {
        const gpu = this.gpu;
        // gpu.begin();
        // this.setEncoder(gpu);
        if (this.renderToScreen) { this.prepareRenderToScreen(gpu.getContextView()); }// only render to screen need this
        this.beginCurrentPass();
        // this.setPipeline(renderPipeline);
        // these things should be generated by compute shader.
        // const combinedVBuffer = verticesBuffer;
        // const combinedIBuffer = indicesBuffer;
        // const indirectBufferSingle = cubeBuffer;
        // this.setVertexBuffer(0, combinedVBuffer);
        // this.setIndexBuffer(combinedIBuffer, 'uint16');
        // this.setBindGroup(bindGroupIndex, bindGroup);
        // // this should be a for loop  maybe it support multi in the future.
        // // for(let i=0;i<drwaCount;i++) // thats the multi API 
        // // {
        // //     this.drawIndexedIndirect(cubeBuffer[i], 0);
        // // }
        // this.drawIndexedIndirect(cubeBuffer, 0);
        this.endCurrentPass();
        // gpu.end();
    }
}